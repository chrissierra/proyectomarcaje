{"remainingRequest":"C:\\Users\\Chris\\Desktop\\Marcaje\\retomando29092018\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\Chris\\Desktop\\Marcaje\\retomando29092018\\node_modules\\ngx-webcam\\ngx-webcam.es5.js","dependencies":[{"path":"C:\\Users\\Chris\\Desktop\\Marcaje\\retomando29092018\\node_modules\\ngx-webcam\\ngx-webcam.es5.js","mtime":1538244215791},{"path":"C:\\Users\\Chris\\Desktop\\Marcaje\\retomando29092018\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1538244206341},{"path":"C:\\Users\\Chris\\Desktop\\Marcaje\\retomando29092018\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1538244190919}],"contextDependencies":[],"result":["import { Component, EventEmitter, Input, NgModule, Output, ViewChild } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * Container class for a captured webcam image\n * @author basst314\n */\nvar WebcamImage = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} imageAsDataUrl\n     * @param {?} mimeType\n     */\n    function WebcamImage(imageAsDataUrl, mimeType) {\n        this._mimeType = null;\n        this._imageAsBase64 = null;\n        this._imageAsDataUrl = null;\n        this._mimeType = mimeType;\n        this._imageAsDataUrl = imageAsDataUrl;\n    }\n    Object.defineProperty(WebcamImage.prototype, \"imageAsBase64\", {\n        /**\n         * Get the base64 encoded image data\n         * @return {?}\n         */\n        get: function () {\n            return this._imageAsBase64 ?\n                this._imageAsBase64 : this._imageAsBase64 = this.getDataFromDataUrl(this._imageAsDataUrl);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WebcamImage.prototype, \"imageAsDataUrl\", {\n        /**\n         * Get the encoded image as dataUrl\n         * @return {?}\n         */\n        get: function () {\n            return this._imageAsDataUrl;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Extracts the Base64 data out of the given dataUrl.\n     * @param {?} dataUrl\n     * @return {?}\n     */\n    WebcamImage.prototype.getDataFromDataUrl = function (dataUrl) {\n        return dataUrl.replace(\"data:\" + this._mimeType + \";base64,\", \"\");\n    };\n    return WebcamImage;\n}());\nvar WebcamUtil = /*@__PURE__*/ (function () {\n    function WebcamUtil() {\n    }\n    /**\n     * Lists available videoInput devices\n     * @return {?}\n     */\n    WebcamUtil.getAvailableVideoInputs = function () {\n        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n            return Promise.reject(\"enumerateDevices() not supported.\");\n        }\n        return new Promise(function (resolve, reject) {\n            navigator.mediaDevices.enumerateDevices()\n                .then(function (devices) {\n                resolve(devices.filter(function (device) { return device.kind === 'videoinput'; }));\n            })\n                .catch(function (err) {\n                reject(err.message || err);\n            });\n        });\n    };\n    return WebcamUtil;\n}());\nvar WebcamComponent = /*@__PURE__*/ (function () {\n    function WebcamComponent() {\n        /**\n         * Defines the max width of the webcam area in px\n         */\n        this.width = 640;\n        /**\n         * Defines the max height of the webcam area in px\n         */\n        this.height = 480;\n        /**\n         * Defines base constraints to apply when requesting video track from UserMedia\n         */\n        this.videoOptions = WebcamComponent.DEFAULT_VIDEO_OPTIONS;\n        /**\n         * Flag to enable/disable camera switch. If enabled, a switch icon will be displayed if multiple cameras were found\n         */\n        this.allowCameraSwitch = true;\n        /**\n         * MediaStream object in use for streaming UserMedia data\n         */\n        this.mediaStream = null;\n        /**\n         * available video devices\n         */\n        this.availableVideoInputs = [];\n        /**\n         * Index of active video in availableVideoInputs\n         */\n        this.activeVideoInputIndex = -1;\n        /**\n         * Indicates whether the video device is ready to be switched\n         */\n        this.videoInitialized = false;\n        /**\n         * EventEmitter which fires when an image has been captured\n         */\n        this.imageCapture = new EventEmitter();\n        /**\n         * Emits a mediaError if webcam cannot be initialized (e.g. missing user permissions)\n         */\n        this.initError = new EventEmitter();\n        /**\n         * Emits when the webcam video was clicked\n         */\n        this.imageClick = new EventEmitter();\n        /**\n         * Emits the active deviceId after the active video device was switched\n         */\n        this.cameraSwitched = new EventEmitter();\n        this.activeVideoSettings = null;\n    }\n    /**\n     * @return {?}\n     */\n    WebcamComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.detectAvailableDevices()\n            .then(function (devices) {\n            // start first device\n            _this.switchToVideoInput(devices.length > 0 ? devices[0].deviceId : null);\n        })\n            .catch(function (err) {\n            _this.initError.next(/** @type {?} */ ({ message: err }));\n            // fallback: still try to load webcam, even if device enumeration failed\n            _this.switchToVideoInput(null);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    WebcamComponent.prototype.ngOnDestroy = function () {\n        this.stopMediaTracks();\n        this.unsubscribeFromSubscriptions();\n    };\n    Object.defineProperty(WebcamComponent.prototype, \"trigger\", {\n        /**\n         * If the given Observable emits, an image will be captured and emitted through 'imageCapture' EventEmitter\n         * @param {?} trigger\n         * @return {?}\n         */\n        set: function (trigger) {\n            var _this = this;\n            if (this.triggerSubscription) {\n                this.triggerSubscription.unsubscribe();\n            }\n            // Subscribe to events from this Observable to take snapshots\n            this.triggerSubscription = trigger.subscribe(function () {\n                _this.takeSnapshot();\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WebcamComponent.prototype, \"switchCamera\", {\n        /**\n         * @param {?} switchCamera\n         * @return {?}\n         */\n        set: function (switchCamera) {\n            var _this = this;\n            if (this.switchCameraSubscription) {\n                this.switchCameraSubscription.unsubscribe();\n            }\n            // Subscribe to events from this Observable to switch video device\n            this.switchCameraSubscription = switchCamera.subscribe(function (value) {\n                if (typeof value === 'string') {\n                    // deviceId was specified\n                    _this.switchToVideoInput(value);\n                }\n                else {\n                    // direction was specified\n                    _this.rotateVideoInput(value !== false);\n                }\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get MediaTrackConstraints to request streaming the given device\n     * @param {?} deviceId\n     * @param {?} baseMediaTrackConstraints base constraints to merge deviceId-constraint into\n     * @return {?}\n     */\n    WebcamComponent.getMediaConstraintsForDevice = function (deviceId, baseMediaTrackConstraints) {\n        var /** @type {?} */ result = baseMediaTrackConstraints ? baseMediaTrackConstraints : this.DEFAULT_VIDEO_OPTIONS;\n        if (deviceId) {\n            result.deviceId = { exact: deviceId };\n        }\n        return result;\n    };\n    /**\n     * Tries to harvest the deviceId from the given mediaStreamTrack object.\n     * Browsers populate this object differently; this method tries some different approaches\n     * to read the id.\n     * @param {?} mediaStreamTrack\n     * @return {?}\n     */\n    WebcamComponent.getDeviceIdFromMediaStreamTrack = function (mediaStreamTrack) {\n        if (mediaStreamTrack.getSettings && mediaStreamTrack.getSettings() && mediaStreamTrack.getSettings().deviceId) {\n            return mediaStreamTrack.getSettings().deviceId;\n        }\n        else if (mediaStreamTrack.getConstraints && mediaStreamTrack.getConstraints() && mediaStreamTrack.getConstraints().deviceId) {\n            var /** @type {?} */ deviceIdObj = mediaStreamTrack.getConstraints().deviceId;\n            return WebcamComponent.getValueFromConstrainDOMString(deviceIdObj);\n        }\n    };\n    /**\n     * Tries to harvest the facingMode from the given mediaStreamTrack object.\n     * Browsers populate this object differently; this method tries some different approaches\n     * to read the value.\n     * @param {?} mediaStreamTrack\n     * @return {?}\n     */\n    WebcamComponent.getFacingModeFromMediaStreamTrack = function (mediaStreamTrack) {\n        if (mediaStreamTrack) {\n            if (mediaStreamTrack.getSettings && mediaStreamTrack.getSettings() && mediaStreamTrack.getSettings().facingMode) {\n                return mediaStreamTrack.getSettings().facingMode;\n            }\n            else if (mediaStreamTrack.getConstraints && mediaStreamTrack.getConstraints() && mediaStreamTrack.getConstraints().facingMode) {\n                var /** @type {?} */ facingModeConstraint = mediaStreamTrack.getConstraints().facingMode;\n                return WebcamComponent.getValueFromConstrainDOMString(facingModeConstraint);\n            }\n        }\n    };\n    /**\n     * Determines whether the given mediaStreamTrack claims itself as user facing\n     * @param {?} mediaStreamTrack\n     * @return {?}\n     */\n    WebcamComponent.isUserFacing = function (mediaStreamTrack) {\n        var /** @type {?} */ facingMode = WebcamComponent.getFacingModeFromMediaStreamTrack(mediaStreamTrack);\n        return facingMode ? \"user\" === facingMode.toLowerCase() : false;\n    };\n    /**\n     * Extracts the value from the given ConstrainDOMString\n     * @param {?} constrainDOMString\n     * @return {?}\n     */\n    WebcamComponent.getValueFromConstrainDOMString = function (constrainDOMString) {\n        if (constrainDOMString) {\n            if (constrainDOMString instanceof String) {\n                return String(constrainDOMString);\n            }\n            else if (Array.isArray(constrainDOMString) && Array(constrainDOMString).length > 0) {\n                return String(constrainDOMString[0]);\n            }\n            else if (typeof constrainDOMString === \"object\") {\n                if (constrainDOMString[\"exact\"]) {\n                    return String(constrainDOMString[\"exact\"]);\n                }\n                else if (constrainDOMString[\"ideal\"]) {\n                    return String(constrainDOMString[\"ideal\"]);\n                }\n            }\n        }\n        return null;\n    };\n    /**\n     * Takes a snapshot of the current webcam's view and emits the image as an event\n     * @return {?}\n     */\n    WebcamComponent.prototype.takeSnapshot = function () {\n        // set canvas size to actual video size\n        var /** @type {?} */ _video = this.video.nativeElement;\n        var /** @type {?} */ dimensions = { width: this.width, height: this.height };\n        if (_video.videoWidth) {\n            dimensions.width = _video.videoWidth;\n            dimensions.height = _video.videoHeight;\n        }\n        var /** @type {?} */ _canvas = this.canvas.nativeElement;\n        _canvas.width = dimensions.width;\n        _canvas.height = dimensions.height;\n        // paint snapshot image to canvas\n        _canvas.getContext('2d').drawImage(this.video.nativeElement, 0, 0);\n        // read canvas content as image\n        // TODO allow mimeType options as Input()\n        var /** @type {?} */ mimeType = \"image/jpeg\";\n        var /** @type {?} */ dataUrl = _canvas.toDataURL(mimeType);\n        this.imageCapture.next(new WebcamImage(dataUrl, mimeType));\n    };\n    /**\n     * Switches to the next/previous video device\n     * @param {?} forward\n     * @return {?}\n     */\n    WebcamComponent.prototype.rotateVideoInput = function (forward) {\n        if (this.availableVideoInputs && this.availableVideoInputs.length > 1) {\n            var /** @type {?} */ increment = forward ? 1 : (this.availableVideoInputs.length - 1);\n            this.switchToVideoInput(this.availableVideoInputs[(this.activeVideoInputIndex + increment) % this.availableVideoInputs.length].deviceId);\n        }\n    };\n    /**\n     * Switches the camera-view to the specified video device\n     * @param {?} deviceId\n     * @return {?}\n     */\n    WebcamComponent.prototype.switchToVideoInput = function (deviceId) {\n        this.videoInitialized = false;\n        this.stopMediaTracks();\n        this.initWebcam(deviceId, this.videoOptions);\n    };\n    Object.defineProperty(WebcamComponent.prototype, \"videoWidth\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ videoRatio = this.getVideoAspectRatio(this.activeVideoSettings);\n            return Math.min(this.width, this.height * videoRatio);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WebcamComponent.prototype, \"videoHeight\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ videoRatio = this.getVideoAspectRatio(this.activeVideoSettings);\n            return Math.min(this.height, this.width / videoRatio);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WebcamComponent.prototype, \"videoStyleClasses\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ classes = \"\";\n            if (this.isMirrorImage()) {\n                classes += \"mirrored \";\n            }\n            return classes.trim();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Return the video aspect ratio from the given mediaTrackSettings, if possible;\n     * Otherwise, calculate given the width/height parameters only\n     * @param {?} mediaTrackSettings\n     * @return {?}\n     */\n    WebcamComponent.prototype.getVideoAspectRatio = function (mediaTrackSettings) {\n        if (mediaTrackSettings) {\n            if (mediaTrackSettings.aspectRatio) {\n                // if ratio is present - use it\n                return mediaTrackSettings.aspectRatio;\n            }\n            else if (mediaTrackSettings.width && mediaTrackSettings.width > 0 &&\n                mediaTrackSettings.height && mediaTrackSettings.height > 0) {\n                // if width+height are present - calculate ratio\n                return mediaTrackSettings.width / mediaTrackSettings.height;\n            }\n        }\n        // nothing present in mediaTrackSettings - calculate ratio based on width/height params\n        return this.width / this.height;\n    };\n    /**\n     * Init webcam live view\n     * @param {?} deviceId\n     * @param {?} userVideoTrackConstraints\n     * @return {?}\n     */\n    WebcamComponent.prototype.initWebcam = function (deviceId, userVideoTrackConstraints) {\n        var _this = this;\n        var /** @type {?} */ _video = this.video.nativeElement;\n        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n            // merge deviceId -> userVideoTrackConstraints\n            var /** @type {?} */ videoTrackConstraints = WebcamComponent.getMediaConstraintsForDevice(deviceId, userVideoTrackConstraints);\n            navigator.mediaDevices.getUserMedia(/** @type {?} */ ({ video: videoTrackConstraints }))\n                .then(function (stream) {\n                _this.mediaStream = stream;\n                _video.srcObject = stream;\n                _video.play();\n                _this.activeVideoSettings = stream.getVideoTracks()[0].getSettings();\n                var /** @type {?} */ activeDeviceId = WebcamComponent.getDeviceIdFromMediaStreamTrack(stream.getVideoTracks()[0]);\n                _this.activeVideoInputIndex = activeDeviceId ? _this.availableVideoInputs\n                    .findIndex(function (mediaDeviceInfo) { return mediaDeviceInfo.deviceId === activeDeviceId; }) : -1;\n                _this.videoInitialized = true;\n                _this.cameraSwitched.next(activeDeviceId);\n            })\n                .catch(function (err) {\n                _this.initError.next(/** @type {?} */ ({ message: err.message, mediaStreamError: err }));\n            });\n        }\n        else {\n            this.initError.next(/** @type {?} */ ({ message: \"Cannot read UserMedia from MediaDevices.\" }));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    WebcamComponent.prototype.getActiveVideoTrack = function () {\n        return this.mediaStream ? this.mediaStream.getVideoTracks()[0] : null;\n    };\n    /**\n     * @return {?}\n     */\n    WebcamComponent.prototype.isMirrorImage = function () {\n        if (!this.getActiveVideoTrack()) {\n            return false;\n        }\n        // check for explicit mirror override parameter\n        {\n            var /** @type {?} */ mirror = \"auto\";\n            if (this.mirrorImage) {\n                if (typeof this.mirrorImage === \"string\") {\n                    mirror = String(this.mirrorImage).toLowerCase();\n                }\n                else {\n                    // WebcamMirrorProperties\n                    if (this.mirrorImage.x) {\n                        mirror = this.mirrorImage.x.toLowerCase();\n                    }\n                }\n            }\n            switch (mirror) {\n                case \"always\":\n                    return true;\n                case \"never\":\n                    return false;\n            }\n        }\n        // default: enable mirroring if webcam is user facing\n        return WebcamComponent.isUserFacing(this.getActiveVideoTrack());\n    };\n    /**\n     * Stops all active media tracks.\n     * This prevents the webcam from being indicated as active,\n     * even if it is no longer used by this component.\n     * @return {?}\n     */\n    WebcamComponent.prototype.stopMediaTracks = function () {\n        if (this.mediaStream && this.mediaStream.getTracks) {\n            // getTracks() returns all media tracks (video+audio)\n            this.mediaStream.getTracks()\n                .forEach(function (track) { return track.stop(); });\n        }\n    };\n    /**\n     * Unsubscribe from all open subscriptions\n     * @return {?}\n     */\n    WebcamComponent.prototype.unsubscribeFromSubscriptions = function () {\n        if (this.triggerSubscription) {\n            this.triggerSubscription.unsubscribe();\n        }\n        if (this.switchCameraSubscription) {\n            this.switchCameraSubscription.unsubscribe();\n        }\n    };\n    /**\n     * Reads available input devices\n     * @return {?}\n     */\n    WebcamComponent.prototype.detectAvailableDevices = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            WebcamUtil.getAvailableVideoInputs()\n                .then(function (devices) {\n                _this.availableVideoInputs = devices;\n                resolve(devices);\n            })\n                .catch(function (err) {\n                _this.availableVideoInputs = [];\n                reject(err);\n            });\n        });\n    };\n    WebcamComponent.DEFAULT_VIDEO_OPTIONS = { facingMode: 'environment' };\n    return WebcamComponent;\n}());\nvar COMPONENTS = [\n    WebcamComponent\n];\nvar WebcamModule = /*@__PURE__*/ (function () {\n    function WebcamModule() {\n    }\n    return WebcamModule;\n}());\nvar WebcamInitError = /*@__PURE__*/ (function () {\n    function WebcamInitError() {\n        this.message = null;\n        this.mediaStreamError = null;\n    }\n    return WebcamInitError;\n}());\nvar WebcamMirrorProperties = /*@__PURE__*/ (function () {\n    function WebcamMirrorProperties() {\n    }\n    return WebcamMirrorProperties;\n}());\n/**\n * Generated bundle index. Do not edit.\n */\nexport { WebcamModule, WebcamComponent, WebcamImage, WebcamInitError, WebcamMirrorProperties, WebcamUtil };\n//# sourceMappingURL=ngx-webcam.es5.js.map\n",null]}