{"remainingRequest":"C:\\Users\\Chris\\Desktop\\Marcaje\\retomando29092018\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\Chris\\Desktop\\Marcaje\\retomando29092018\\node_modules\\rxjs\\_esm5\\internal\\observable\\bindNodeCallback.js","dependencies":[{"path":"C:\\Users\\Chris\\Desktop\\Marcaje\\retomando29092018\\node_modules\\rxjs\\_esm5\\internal\\observable\\bindNodeCallback.js","mtime":1538244219737},{"path":"C:\\Users\\Chris\\Desktop\\Marcaje\\retomando29092018\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1538244206341},{"path":"C:\\Users\\Chris\\Desktop\\Marcaje\\retomando29092018\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1538244190919}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_isScheduler,_util_isArray PURE_IMPORTS_END */\r\nimport { Observable } from '../Observable';\r\nimport { AsyncSubject } from '../AsyncSubject';\r\nimport { map } from '../operators/map';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { isArray } from '../util/isArray';\r\nexport function bindNodeCallback(callbackFunc, resultSelector, scheduler) {\r\n    if (resultSelector) {\r\n        if (isScheduler(resultSelector)) {\r\n            scheduler = resultSelector;\r\n        }\r\n        else {\r\n            return function () {\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\r\n            };\r\n        }\r\n    }\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var params = {\r\n            subject: undefined,\r\n            args: args,\r\n            callbackFunc: callbackFunc,\r\n            scheduler: scheduler,\r\n            context: this,\r\n        };\r\n        return new Observable(function (subscriber) {\r\n            var context = params.context;\r\n            var subject = params.subject;\r\n            if (!scheduler) {\r\n                if (!subject) {\r\n                    subject = params.subject = new AsyncSubject();\r\n                    var handler = function () {\r\n                        var innerArgs = [];\r\n                        for (var _i = 0; _i < arguments.length; _i++) {\r\n                            innerArgs[_i] = arguments[_i];\r\n                        }\r\n                        var err = innerArgs.shift();\r\n                        if (err) {\r\n                            subject.error(err);\r\n                            return;\r\n                        }\r\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\r\n                        subject.complete();\r\n                    };\r\n                    try {\r\n                        callbackFunc.apply(context, args.concat([handler]));\r\n                    }\r\n                    catch (err) {\r\n                        subject.error(err);\r\n                    }\r\n                }\r\n                return subject.subscribe(subscriber);\r\n            }\r\n            else {\r\n                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });\r\n            }\r\n        });\r\n    };\r\n}\r\nfunction dispatch(state) {\r\n    var _this = this;\r\n    var params = state.params, subscriber = state.subscriber, context = state.context;\r\n    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;\r\n    var subject = params.subject;\r\n    if (!subject) {\r\n        subject = params.subject = new AsyncSubject();\r\n        var handler = function () {\r\n            var innerArgs = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                innerArgs[_i] = arguments[_i];\r\n            }\r\n            var err = innerArgs.shift();\r\n            if (err) {\r\n                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\r\n            }\r\n            else {\r\n                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\r\n                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\r\n            }\r\n        };\r\n        try {\r\n            callbackFunc.apply(context, args.concat([handler]));\r\n        }\r\n        catch (err) {\r\n            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\r\n        }\r\n    }\r\n    this.add(subject.subscribe(subscriber));\r\n}\r\nfunction dispatchNext(arg) {\r\n    var value = arg.value, subject = arg.subject;\r\n    subject.next(value);\r\n    subject.complete();\r\n}\r\nfunction dispatchError(arg) {\r\n    var err = arg.err, subject = arg.subject;\r\n    subject.error(err);\r\n}\r\n//# sourceMappingURL=bindNodeCallback.js.map\r\n",null]}